import { useState, useRef } from 'react';
import FontSelector from './FontSelector';
import { jsPDF } from 'jspdf';

const HandwritingConverter = () => {
  const [text, setText] = useState('');
  const [fontFamily, setFontFamily] = useState('Dancing Script Regular');
  const [fontSize, setFontSize] = useState(24);
  const [fontColor, setFontColor] = useState('#000000');
  const [backgroundColor, setBackgroundColor] = useState('#ffffff');
  const [pageSize, setPageSize] = useState('a4');
  const textAreaRef = useRef<HTMLDivElement>(null);

  // Function to wrap text and handle multi-line rendering
  const wrapText = (context: CanvasRenderingContext2D, text: string, x: number, y: number, maxWidth: number, lineHeight: number) => {
    const words = text.split(' ');
    let line = '';
    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + ' ';
      const metrics = context.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && i > 0) {
        context.fillText(line, x, y);
        line = words[i] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
  };

  const downloadAsImageOrPdf = (format: 'png' | 'pdf') => {
    const textArea = textAreaRef.current;
    if (textArea) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (context) {
        const canvasWidth = 600;
        const canvasHeight = 800;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Set background color
        context.fillStyle = backgroundColor;
        context.fillRect(0, 0, canvasWidth, canvasHeight);

        // Set font styles
        context.font = `${fontSize}px ${fontFamily}`;
        context.fillStyle = fontColor;

        // Adjusting text positioning with margins
        const lineHeight = fontSize * 1.2;
        const x = 20;
        let y = 40;

        // Wrap text inside the canvas width
        wrapText(context, text, x, y, canvasWidth - 40, lineHeight);

        if (format === 'png') {
          // Create a PNG and download
          const link = document.createElement('a');
          link.href = canvas.toDataURL('image/png');
          link.download = 'handwriting.png';
          link.click();
        } else if (format === 'pdf') {
          // Create a new PDF
          const pdf = new jsPDF({ format: pageSize });

          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();

          // Compute aspect ratios for scaling
          const canvasRatio = canvasWidth / canvasHeight;
          const pageRatio = pageWidth / pageHeight;

          let pdfWidth, pdfHeight;
          if (canvasRatio > pageRatio) {
            // Fit by width
            pdfWidth = pageWidth - 20;
            pdfHeight = pdfWidth / canvasRatio;
          } else {
            // Fit by height
            pdfHeight = pageHeight - 20;
            pdfWidth = pdfHeight * canvasRatio;
          }

          // Handle multi-page content
          const imgData = canvas.toDataURL('image/png');
          let remainingText = text;
          let currentY = 10;

          // Calculate how much text fits on one page
          const maxLinesPerPage = Math.floor((pageHeight - 20) / lineHeight);
          const lines = text.split('\n');
          
          // Split the text into pages
          for (let i = 0; i < lines.length; i += maxLinesPerPage) {
            const pageText = lines.slice(i, i + maxLinesPerPage).join('\n');

            // Add image to the PDF
            if (i > 0) {
              pdf.addPage();
            }

            pdf.addImage(imgData, 'PNG', 10, 10, pdfWidth, pdfHeight);

            // Render text for this page
            remainingText = remainingText.substring(pageText.length);
          }

          // Download the PDF
          pdf.save('handwriting.pdf');
        }
      }
    }
  };

  return (
    <div>
      <FontSelector setFontFamily={setFontFamily} />

      <div>
        <label>Font Size:</label>
        <input
          type="number"
          value={fontSize}
          onChange={(e) => setFontSize(Number(e.target.value))}
        />
      </div>

      <div>
        <label>Font Color:</label>
        <input
          type="color"
          value={fontColor}
          onChange={(e) => setFontColor(e.target.value)}
        />
      </div>

      <div>
        <label>Background Color:</label>
        <input
          type="color"
          value={backgroundColor}
          onChange={(e) => setBackgroundColor(e.target.value)}
        />
      </div>

      <div>
        <label>Page Size:</label>
        <select value={pageSize} onChange={(e) => setPageSize(e.target.value)}>
          <option value="a4">A4</option>
          <option value="letter">Letter</option>
        </select>
      </div>

      <div
        ref={textAreaRef}
        style={{
          fontFamily: fontFamily,
          fontSize: `${fontSize}px`,
          color: fontColor,
          backgroundColor: backgroundColor,
          width: '100%',
          height: '200px',
          padding: '10px',
          border: '1px solid #ddd',
          overflow: 'auto',
          whiteSpace: 'pre-wrap',
          margin: '20px 0',
        }}
        contentEditable
        onInput={(e) => setText(e.currentTarget.textContent || '')}
      >
        {text}
      </div>

      <button onClick={() => downloadAsImageOrPdf('png')}>Download as PNG</button>
      <button onClick={() => downloadAsImageOrPdf('pdf')}>Download as PDF</button>
    </div>
  );
};

export default HandwritingConverter;
